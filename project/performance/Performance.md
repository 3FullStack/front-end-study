## 优化内容效率

### 避免不必要的下载

- 消除不必要的资源
- 评估一项资源给用户提供的价值是否可以抵消其开销：比如轮播图，是否有必要把所有的图片都下载下来

### 优化、压缩必要的资源

- 使用通用压缩程序压缩数据
- 数据预处理：去除注释、合并css等其他内容的特定优化（因此，需要建立一个不同类型内容的清单，然后针对不同类型进行优化）
- 基于文本的资源使用 gzip 压缩，现代浏览器均支持并默认使用 gzip。

### 图像优化：

- 消除和替换图像：消除多余的图像、尽可能利用 CSS3 效果替代图像
- 明确什么时候使用矢量图像（简单几何形状），什么时候使用光栅图像（场景复杂）
- 高分辨率屏幕尽量使用矢量图像（CSS 像素可能对应好几个设备像素，对应的设备像素越多，屏幕越高清）；如果使用光栅图像，可以使用 picture 标签和 srcset 属性优化
- 矢量图对 svg 文件进行压缩、再使用 gzip 压缩；光栅图像减少每个像素需要的位数来压缩图像
- 根据自己需要合理选择有损压缩（去除某些像素数据）和无损压缩（压缩像素数据）
- 选择正确的图片格式：

  | 格式     | 透明度 | 动画   | 浏览器 |
  | :--:    | :--:  | :--:   | :--: |
  | GIF     | 支持   | 支持   | 所有 |
  | PNG     | 支持   | 不支持  | 所有 |
  | JPEG    | 不支持 | 不支持  | 所有 |
  | JPEG XR | 支持   | 支持   | IE |
  | WebP    | 支持   | 支持   | Chrome、Opera、Android |

  ![](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/images/format-tree.png)

- 位图的大小由像素个数以及每个像素所需的字节数决定，所以优化位图可以从这两方面入手

综上，有以下优化图像技巧：1）首选矢量格式；2）缩小和压缩 SVG 资产；3）挑选最佳光栅图片格式；4）通过试验为光栅格式找到最佳质量设置；5）移除多余的图像元数据；6）提供缩放的图像；7）自动化、自动化、自动化

### 网页字体优化

- 选择合适的网页字体格式（TTF, EOT, WOFF, WOFF2）
- 压缩字体文件
- 利用 `@font-face` 定义字体系列
- 优化加载和渲染：浏览器必须构建渲染树（它依赖 DOM 和 CSSOM 树），然后才能知道需要使用哪些字体资源来渲染文本。但可以使用脚本立刻加载字体；还可以缓存字体文件

### HTTP 缓存

- ETag：客户端自动在“If-None-Match” HTTP 请求标头内提供 ETag 令牌。服务器根据当前资源核对令牌。如果它未发生变化，服务器将返回“304 Not Modified”响应，告知浏览器缓存中的响应未发生变化
- Cache-Control：
  - `no-cache`：不缓存，但必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求；`no-store`：无论资源有没有发生变化，必须重新向服务器请求
  - `private`：只为单个用户缓存，因此不允许任何中间缓存对其进行缓存。例如，用户的浏览器可以缓存包含用户私人信息的 HTML 网页，但 CDN 却不能缓存。`public`：表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存
  - `max-age`：允许存活最长时间
- 定义不同的文件名来废弃原缓存，比如 style.x234dff.css 改为 style.3dss8fe.css
